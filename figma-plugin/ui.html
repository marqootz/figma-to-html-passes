<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Figma to HTML</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            line-height: 1.4;
            color: #333;
            background: #ececec;
            overflow-y: auto;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        .container {
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #000000;
            padding: 16px;
            margin-bottom: 0;
        }

        .title {
            font-size: 28px;
            font-weight: 500;
            color: #ffffff;
            margin-bottom: 4px;
        }

        .subtitle {
            font-size: 12px;
            font-weight: 400;
            color: #ffffff;
        }

        .section {
            margin-bottom: 16px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 400;
            color: #000;
            margin-bottom: 8px;
        }

        .input-group {
        }

        .input {
            width: 100%;
            padding: 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            font-size: 12px;
            background: #fff;
            height: 32px;
            box-sizing: border-box;
        }

        select.input {
            padding: 8px 32px 8px 8px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='7' height='4' viewBox='0 0 7 4' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M3.502 4C3.433 4 3.37 3.987 3.312 3.961C3.254 3.935 3.199 3.895 3.146 3.843L0.134 0.782C0.045 0.695 0 0.588 0 0.46C0 0.376 0.021 0.299 0.063 0.228C0.103 0.157 0.158 0.101 0.229 0.059C0.298 0.02 0.374 0 0.458 0C0.585 0 0.697 0.047 0.794 0.141L3.502 2.9L6.209 0.141C6.307 0.047 6.418 0 6.542 0C6.628 0 6.706 0.02 6.775 0.059C6.843 0.101 6.897 0.157 6.937 0.228C6.979 0.299 7 0.376 7 0.46C7 0.588 6.957 0.695 6.87 0.782L3.858 3.843C3.805 3.895 3.75 3.935 3.692 3.961C3.634 3.987 3.57 4 3.502 4Z' fill='rgba(0,0,0,1)'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            cursor: pointer;
            height: 32px;
            box-sizing: border-box;
        }

        textarea.input {
            height: auto;
            min-height: 100px;
            resize: vertical;
        }

        .input:focus {
            outline: none;
            border-color: #0d99ff;
        }

        .button {
            width: 100%;
            padding: 8px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 400;
            cursor: pointer;
            transition: background-color 0.2s;
            height: 33px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .button-primary {
            background: #2d64dd;
            color: #ffffff;
        }

        .button-primary:hover:not(:disabled) {
            background: #2559c4;
        }

        .button-primary:disabled {
            background: #e1e5e9;
            color: #8c8c8c;
            cursor: not-allowed;
        }

        .button-purple {
            background: #c564de;
            color: #ffffff;
        }

        .button-purple:hover:not(:disabled) {
            background: #b554cd;
        }

        .button-secondary {
            background: #f1f3f4;
            color: #333;
        }

        .button-secondary:hover {
            background: #e8eaed;
        }

        .status {
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 8px;
        }

        .status.info {
            background: #e7f3ff;
            color: #0066cc;
            border: 1px solid #b3d9ff;
        }

        .status.success {
            background: #e8f5e8;
            color: #006600;
            border: 1px solid #b3d9b3;
        }

        .status.error {
            background: #ffeaea;
            color: #cc0000;
            border: 1px solid #ffb3b3;
        }

        .hidden {
            display: none;
        }

        .node-list {
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #e1e5e9;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .node-item {
            padding: 4px 8px;
            font-size: 11px;
            border-bottom: 1px solid #e1e5e9;
        }

        .node-item:last-child {
            border-bottom: none;
        }

        .node-type {
            color: #666;
            font-weight: 500;
        }
        
        .help-text {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 8px;
        }

        .section-header {
            font-size: 20px;
            font-weight: 500;
            color: #000;
            margin-bottom: 8px;
        }

        .section-subtitle {
            font-size: 12px;
            font-weight: 400;
            color: #000;
            margin-bottom: 16px;
        }

        .sections-wrapper {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 16px;
        }

        .section-container {
            background: #ffffff;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0px 4px 16px 0px rgba(0, 0, 0, 0.16);
        }

        .step-container {
            display: flex;
            gap: 10px;
            margin-bottom: 24px;
        }

        .step-number {
            font-size: 20px;
            font-weight: 500;
            color: #000;
            flex-shrink: 0;
            width: 12px;
        }

        .step-content {
            flex: 1;
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(2px);
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-container {
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0px 4px 16px 0px rgba(0, 0, 0, 0.16);
            max-width: 90%;
            max-height: 85vh;
            width: 400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            outline: none;
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e1e5e9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 500;
            color: #000;
        }

        .modal-close {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .modal-close:hover {
            background: #f1f3f4;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 12px 20px;
            border-top: 1px solid #e1e5e9;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="title">Figma to HTML</div>
            <div class="subtitle">Convert Figma prototypes to be used in UXync and Showroom</div>
        </div>

        <!-- Sections Wrapper -->
        <div class="sections-wrapper">
            <!-- Showroom Section -->
            <div class="section-container">
                <div class="section-header">Showroom</div>
                <div class="section-subtitle">Presentation content for GDF Showroom</div>

                <!-- Google Drive Status (hidden in main UI, shown in settings) -->
                <div class="section" style="display: none;">
                    <div class="input-group" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <span style="font-size: 11px; color: #666;">Google Drive:</span>
                        <span id="drive-status" style="font-size: 11px; color: #666;">Checking...</span>
                    </div>
                    <button id="connect-drive" class="button button-secondary" style="display: none; font-size: 11px; padding: 6px;">Connect to Google Drive</button>
                    <button id="settings-drive" class="button button-secondary" style="display: none; font-size: 11px; padding: 6px; margin-top: 4px;">Settings</button>
                </div>



                <!-- Step 1: Configuration -->
                <div class="step-container">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <div style="display: flex; gap: 16px;">
                            <!-- Presentation Selection -->
                            <div style="flex: 1;">
                                <div class="section-title" style="margin-bottom: 8px; font-size: 12px; font-weight: 400;">Presentation:</div>
                                <div style="font-size: 10px; color: #000; opacity: 0.5; margin-bottom: 8px;">Choose an existing or new presentation for export.</div>
                                <div class="input-group" style="position: relative;">
                                    <select id="presentation-select" class="input" style="margin-bottom: 8px;">
                                        <option value="">Select</option>
                                    </select>
                                </div>
                                <div class="input-group" id="new-presentation-group" style="display: none;">
                                    <input type="text" id="new-presentation-name" class="input" placeholder="Enter presentation name" style="margin-bottom: 4px;">
                                    <div id="presentation-name-error" style="font-size: 10px; color: #cc0000; display: none;"></div>
                                </div>
                            </div>

                            <!-- Wall Selection -->
                            <div style="flex: 1;">
                                <div class="section-title" style="margin-bottom: 8px; font-size: 12px; font-weight: 400;">Wall:</div>
                                <div style="font-size: 10px; color: #000; opacity: 0.5; margin-bottom: 8px;">Choose which wall this export is for.</div>
                                <div class="input-group" style="position: relative;">
                                    <select id="wall-select" class="input">
                                        <option value="">Select</option>
                                        <option value="wall1">wall1</option>
                                        <option value="wall2">wall2</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Step 2: Export Actions -->
                <div class="step-container">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <div class="section-title" style="margin-bottom: 8px; font-size: 12px; font-weight: 400;">Export:</div>
                        <div style="font-size: 10px; color: #000; opacity: 0.5; margin-bottom: 12px;">Export both the content and navigation for your presentation.</div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div class="input-group">
                                <button id="export-to-showroom" class="button button-primary" disabled>Export content</button>
                            </div>
                            <div class="input-group">
                                <button id="export-rules" class="button button-primary" disabled>Export navigation</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- UXync Section -->
            <div class="section-container">
                <div class="section-header">UXync</div>
                <div class="section-subtitle">Interactive experiences for UXync UXR system.</div>

                <!-- Local Export Section -->
                <div class="section">
                    <div class="input-group">
                        <button id="export-locally" class="button button-purple">Export</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div style="background: #ececec; padding: 0px 16px 16px 16px; display: flex; justify-content: space-between; align-items: center; margin-top: auto;">
            <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 12px; color: #000; font-weight: 400;">Google Drive</span>
                <span id="drive-status-footer" style="font-size: 12px; color: #000; font-weight: 500;">Checking...</span>
            </div>
            <button id="settings-drive-footer" style="background: none; border: none; cursor: pointer; padding: 0; display: flex; align-items: center; justify-content: center; width: 14px; height: 14px;" title="Settings">
                <svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M5.54755 14 L5.32565 11.9972 C4.95581 11.8806 4.60279 11.7315 4.26657 11.55 C3.93708 11.3685 3.6244 11.1481 3.32853 10.8889 L1.45245 11.6861 L0 9.31389 L1.67435 8.10833 C1.51297 7.36944 1.51297 6.63056 1.67435 5.89167 L0 4.68611 L1.45245 2.31389 L3.32853 3.11111 C3.6244 2.84537 3.93708 2.625 4.26657 2.45 C4.60279 2.26852 4.95581 2.11944 5.32565 2.00278 L5.54755 0 L8.45245 0 L8.67435 2.00278 C9.05091 2.11944 9.4073 2.26852 9.74352 2.45 C10.0797 2.625 10.389 2.84537 10.6715 3.11111 L12.5476 2.31389 L14 4.68611 L12.3256 5.89167 C12.487 6.63056 12.487 7.36944 12.3256 8.10833 L14 9.31389 L12.5476 11.6861 L10.6715 10.8889 C10.389 11.1481 10.0797 11.3685 9.74352 11.55 C9.4073 11.7315 9.05091 11.8806 8.67435 11.9972 L8.45245 14 L5.54755 14 Z M7 9.72222 C7.5245 9.72222 7.99856 9.60231 8.42219 9.3625 C8.85255 9.1162 9.19212 8.78889 9.44092 8.38056 C9.69645 7.96574 9.82421 7.50555 9.82421 7 C9.82421 6.49444 9.69645 6.0375 9.44092 5.62917 C9.19212 5.21435 8.85255 4.88704 8.42219 4.64722 C7.99856 4.40093 7.5245 4.27778 7 4.27778 C6.4755 4.27778 5.99808 4.40093 5.56772 4.64722 C5.14409 4.88704 4.80452 5.21435 4.54899 5.62917 C4.30019 6.0375 4.17579 6.49444 4.17579 7 C4.17579 7.50555 4.30019 7.96574 4.54899 8.38056 C4.80452 8.78889 5.14409 9.1162 5.56772 9.3625 C5.99808 9.60231 6.4755 9.72222 7 9.72222 Z" fill="rgba(0, 0, 0, 1)"/>
                </svg>
            </button>
        </div>

        <!-- Settings Modal -->
        <div id="modal-overlay" class="modal-overlay">
            <div class="modal-container" id="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Settings</div>
                    <button id="modal-close" class="modal-close" title="Close">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4L4 12M4 4L12 12" stroke="#666" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
                <div class="modal-body" id="oauth-settings" style="font-size: 12px;">
                    <!-- Google Drive Connection Status -->
                    <div style="margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid #e1e5e9;">
                        <div style="font-weight: 600; margin-bottom: 12px;">Google Drive Connection</div>
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                            <span style="font-size: 12px; color: #666;">Status:</span>
                            <span id="drive-status-modal" style="font-size: 12px; color: #666; font-weight: 500;">Checking...</span>
                        </div>
                        <button id="connect-drive" class="button button-primary" style="width: 100%; display: none;">Connect to Google Drive</button>
                    </div>

                    <!-- Google Drive Folder ID - Always visible, users may need to change it -->
                    <div style="margin-bottom: 12px;">
                        <div style="font-weight: 600; margin-bottom: 8px;">Google Drive Folder ID</div>
                        <div style="margin-bottom: 8px;">
                            <input type="text" id="drive-folder-id" class="input" placeholder="Enter folder ID from URL" style="font-size: 12px; padding: 8px;">
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">From: drive.google.com/drive/folders/FOLDER_ID</div>
                            <div id="folder-id-build-time-notice" style="font-size: 11px; color: #0066cc; margin-top: 4px; display: none;">Currently using build-time value. Enter a new ID here to override.</div>
                        </div>
                    </div>

                    <!-- Access Token (Manual Entry - Fallback) -->
                    <div id="access-token-section" style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #e1e5e9;">
                        <div style="font-weight: 600; margin-bottom: 8px;">Access Token (Manual Entry - Fallback)</div>
                        <div style="margin-bottom: 8px;">
                            <input type="text" id="oauth-access-token" class="input" placeholder="Paste access token here (fallback if Connect button fails)" style="font-size: 12px; padding: 8px;">
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Only needed if "Connect" button doesn't work. Use Connect button for automatic token acquisition.</div>
                        </div>
                    </div>

                    <!-- OAuth Client ID -->
                    <div id="client-id-section" style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #e1e5e9;">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #1a73e8;">OAuth Client ID</div>
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-weight: 500;">OAuth Client ID:</label>
                            <input type="text" id="oauth-client-id" class="input" placeholder="Enter Google OAuth Client ID" style="font-size: 12px; padding: 8px;">
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Get from Google Cloud Console â†’ Credentials â†’ OAuth 2.0 Client ID</div>
                        </div>
                    </div>

                    <!-- Backend URL -->
                    <div id="backend-url-section" style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #e1e5e9;">
                        <div style="font-weight: 600; margin-bottom: 8px;">Backend URL</div>
                        <div style="margin-bottom: 8px;">
                            <label style="display: block; margin-bottom: 4px; font-weight: 500;">Backend URL (For OAuth/Service Account):</label>
                            <input type="text" id="auth-backend-url" class="input" placeholder="https://your-backend.com/api" style="font-size: 12px; padding: 8px;">
                            <div style="font-size: 11px; color: #666; margin-top: 4px;">Required for backend OAuth flow or service account JWT signing</div>
                        </div>
                    </div>

                    <!-- Service Account (Advanced - Optional) -->
                    <details id="service-account-section" style="margin-bottom: 12px; padding-top: 12px; border-top: 1px solid #e1e5e9;">
                        <summary style="font-weight: 600; cursor: pointer; margin-bottom: 8px; color: #666;">Service Account (Advanced - Optional)</summary>
                        <div style="margin-top: 8px;">
                            <div style="margin-bottom: 8px;">
                                <label style="display: block; margin-bottom: 4px; font-weight: 500;">Service Account JSON:</label>
                                <textarea id="service-account-json" class="input" placeholder='Paste service account JSON here: {"type":"service_account",...}' style="font-size: 11px; padding: 8px; height: 100px; font-family: monospace; resize: vertical;"></textarea>
                                <div style="font-size: 11px; color: #666; margin-top: 4px;">For managed deployments. Or configure via GOOGLE_SERVICE_ACCOUNT_JSON env var at build time</div>
                            </div>
                        </div>
                    </details>
                </div>
                <div class="modal-footer">
                    <button id="save-oauth-settings" class="button button-primary" style="width: auto; min-width: 100px;">Save Settings</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        class FigmaToHTMLUI {
            constructor() {
                this.chunkedDownloads = new Map(); // Store chunked downloads
                this.presentations = [];
                this.isConnected = false;
                this.pendingSettingsOpen = false; // Track if Settings panel should be opened after processing
                this.initializeUI();
                this.setupEventListeners();
                this.checkGoogleDriveConnection();
                this.loadPresentations();
            }

            initializeUI() {
                console.log('ðŸŽ¨ Figma to HTML UI initialized');
                
                // Request settings on initialization to check build-time config
                // This ensures we know which sections to hide/remove before user opens settings
                this.sendMessage({ type: 'get-settings' });
                
                this.updateExportButton();
                
                // Initial resize to fixed height
                setTimeout(() => this.resizeUI(), 100);
            }

            setupEventListeners() {
                // Google Drive connection
                document.getElementById('connect-drive').addEventListener('click', () => {
                    this.connectGoogleDrive();
                });

                document.getElementById('settings-drive').addEventListener('click', () => {
                    this.toggleOAuthSettings();
                });

                // Footer settings button
                const settingsFooterBtn = document.getElementById('settings-drive-footer');
                if (settingsFooterBtn) {
                    settingsFooterBtn.addEventListener('click', () => {
                        this.toggleOAuthSettings();
                    });
                }

                document.getElementById('save-oauth-settings').addEventListener('click', () => {
                    this.saveOAuthSettings();
                });

                // Modal close handlers
                document.getElementById('modal-close').addEventListener('click', () => {
                    this.closeModal();
                });

                // Close modal when clicking outside
                document.getElementById('modal-overlay').addEventListener('click', (e) => {
                    if (e.target.id === 'modal-overlay') {
                        this.closeModal();
                    }
                });

                // Close modal on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const overlay = document.getElementById('modal-overlay');
                        if (overlay && overlay.classList.contains('show')) {
                            this.closeModal();
                        }
                    }
                });

                // Presentation dropdown
                document.getElementById('presentation-select').addEventListener('change', (e) => {
                    this.handlePresentationChange(e.target.value);
                });

                // Refresh presentations button

                // New presentation name input
                document.getElementById('new-presentation-name').addEventListener('input', (e) => {
                    this.validatePresentationName(e.target.value);
                });

                // Export buttons
                document.getElementById('export-to-showroom').addEventListener('click', () => {
                    this.exportToShowroom();
                });

                document.getElementById('export-locally').addEventListener('click', () => {
                    this.exportLocally();
                });

                document.getElementById('export-rules').addEventListener('click', () => {
                    this.exportRules();
                });

                // Message listener
                window.addEventListener('message', (event) => {
                    if (event.data.pluginMessage) {
                        this.handleMessage(event.data.pluginMessage);
                    }
                });
            }

            async checkGoogleDriveConnection() {
                this.sendMessage({ type: 'check-drive-connection' });
            }

            async connectGoogleDrive() {
                this.showStatus('Connecting to Google Drive...', 'info');
                this.sendMessage({ type: 'connect-google-drive' });
            }

            async toggleOAuthSettings() {
                const overlay = document.getElementById('modal-overlay');
                const isVisible = overlay && overlay.classList.contains('show');
                
                if (!isVisible) {
                    // Request settings and wait for response before showing modal
                    // This ensures build-time config is checked and sections removed first
                    this.sendMessage({ type: 'get-settings' });
                    // Modal will be shown after settings-loaded message is processed
                    this.pendingSettingsOpen = true;
                } else {
                    this.closeModal();
                }
            }

            openModal() {
                const overlay = document.getElementById('modal-overlay');
                if (overlay) {
                    overlay.classList.add('show');
                    // Focus the modal container for accessibility
                    const container = document.getElementById('modal-container');
                    if (container) {
                        container.focus();
                    }
                }
            }

            closeModal() {
                const overlay = document.getElementById('modal-overlay');
                if (overlay) {
                    overlay.classList.remove('show');
                    this.pendingSettingsOpen = false;
                }
            }

            resizeUI() {
                // Fixed height of 680px
                const height = 680;

                this.sendMessage({
                    type: 'resize-ui',
                    height: height
                });
            }

            async saveOAuthSettings() {
                // Get values only if elements exist (they might be removed if configured at build time)
                const serviceAccountElement = document.getElementById('service-account-json');
                const clientIdElement = document.getElementById('oauth-client-id');
                const accessTokenElement = document.getElementById('oauth-access-token');
                const folderIdElement = document.getElementById('drive-folder-id');
                const backendUrlElement = document.getElementById('auth-backend-url');
                
                const serviceAccountJson = serviceAccountElement ? serviceAccountElement.value.trim() : '';
                const clientId = clientIdElement ? clientIdElement.value.trim() : '';
                const accessToken = accessTokenElement ? accessTokenElement.value.trim() : '';
                const folderId = folderIdElement ? folderIdElement.value.trim() : '';
                const backendUrl = backendUrlElement ? backendUrlElement.value.trim() : '';

                if (serviceAccountJson) {
                    // Validate JSON
                    try {
                        JSON.parse(serviceAccountJson);
                        this.sendMessage({
                            type: 'store-service-account-key',
                            serviceAccountKey: serviceAccountJson
                        });
                    } catch (error) {
                        this.showStatus('Invalid JSON format in Service Account JSON field', 'error');
                        return;
                    }
                }

                if (clientId) {
                    this.sendMessage({
                        type: 'store-client-id',
                        clientId: clientId
                    });
                }

                if (accessToken) {
                    this.sendMessage({
                        type: 'store-access-token',
                        accessToken: accessToken
                    });
                }

                if (folderId) {
                    this.sendMessage({
                        type: 'store-folder-id',
                        folderId: folderId
                    });
                }

                if (backendUrl) {
                    this.sendMessage({
                        type: 'store-backend-url',
                        backendUrl: backendUrl
                    });
                }

                // At minimum, folder ID should be set
                if (!folderId) {
                    this.showStatus('Please enter a Folder ID', 'error');
                    return;
                }

                this.showStatus('Settings saved. Checking connection...', 'info');
                
                // Reload settings to show updated values
                setTimeout(() => {
                    this.sendMessage({ type: 'get-settings' });
                    this.checkGoogleDriveConnection();
                    // Close modal after saving
                    this.closeModal();
                }, 500);
            }

            async loadPresentations() {
                this.sendMessage({ type: 'fetch-presentations' });
            }


            handlePresentationChange(value) {
                const newPresentationGroup = document.getElementById('new-presentation-group');
                const newPresentationName = document.getElementById('new-presentation-name');
                
                if (value === 'new') {
                    newPresentationGroup.style.display = 'block';
                    newPresentationName.focus();
                } else {
                    newPresentationGroup.style.display = 'none';
                    newPresentationName.value = '';
                }
                this.updateExportButton();
            }

            validatePresentationName(name) {
                const errorDiv = document.getElementById('presentation-name-error');
                if (!name || name.trim().length === 0) {
                    errorDiv.textContent = 'Please enter a presentation name';
                    errorDiv.style.display = 'block';
                    return false;
                }
                errorDiv.style.display = 'none';
                return true;
            }

            sanitizePresentationName(input) {
                if (!input || typeof input !== 'string') {
                    return null;
                }
                
                let sanitized = input
                    .trim()
                    .toLowerCase()
                    .replace(/[^a-z0-9\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/-+/g, '-')
                    .replace(/^-|-$/g, '');
                
                if (sanitized.length < 3) {
                    return null;
                }
                
                if (sanitized.length > 50) {
                    sanitized = sanitized.substring(0, 50).replace(/-$/, '');
                }
                
                return sanitized;
            }

            async exportToShowroom() {
                const presentationSelect = document.getElementById('presentation-select');
                const selectedPresentation = presentationSelect.value;
                const newPresentationName = document.getElementById('new-presentation-name').value;
                const wallSelect = document.getElementById('wall-select');
                const selectedWall = wallSelect.value;

                if (!this.isConnected) {
                    this.showStatus('Please connect to Google Drive first', 'error');
                    return;
                }

                let presentationName = null;

                if (selectedPresentation === 'new') {
                    if (!this.validatePresentationName(newPresentationName)) {
                        return;
                    }
                    presentationName = this.sanitizePresentationName(newPresentationName);
                    if (!presentationName) {
                        this.showStatus('Invalid presentation name. Please enter at least 3 characters.', 'error');
                        return;
                    }
                } else if (selectedPresentation) {
                    presentationName = selectedPresentation;
                } else {
                    this.showStatus('Please select a presentation', 'error');
                    return;
                }

                this.showStatus('Preparing export...', 'info');
                this.setExportButtonEnabled(false);

                // Auto-gen slide nav is always enabled for showroom exports
                this.sendMessage({
                    type: 'export-to-showroom',
                    presentationName: presentationName,
                    isNewPresentation: selectedPresentation === 'new',
                    wallName: selectedWall,
                    autoGenerateNavigation: true
                });
            }

            async exportLocally() {
                this.showStatus('Generating HTML from selection...', 'info');
                // Disable local export button during export, but keep showroom buttons enabled
                const exportLocallyButton = document.getElementById('export-locally');
                exportLocallyButton.disabled = true;
                
                // Auto-gen slide nav is not needed for local exports (UXR Uxync)
                this.sendMessage({
                    type: 'generate-html',
                    useSelection: true,
                    autoGenerateNavigation: false,
                    exportLocally: true
                });
            }

            async exportSelected() {
                // Legacy method - redirects to exportLocally
                this.exportLocally();
            }

            async exportRules() {
                const presentationSelect = document.getElementById('presentation-select');
                const selectedPresentation = presentationSelect.value;
                const newPresentationName = document.getElementById('new-presentation-name').value;
                const wallSelect = document.getElementById('wall-select');
                const selectedWall = wallSelect.value;

                if (!this.isConnected) {
                    this.showStatus('Please connect to Google Drive first', 'error');
                    return;
                }

                let presentationName = null;

                if (selectedPresentation === 'new') {
                    if (!this.validatePresentationName(newPresentationName)) {
                        return;
                    }
                    presentationName = this.sanitizePresentationName(newPresentationName);
                    if (!presentationName) {
                        this.showStatus('Invalid presentation name. Please enter at least 3 characters.', 'error');
                        return;
                    }
                } else if (selectedPresentation) {
                    presentationName = selectedPresentation;
                } else {
                    this.showStatus('Please select a presentation', 'error');
                    return;
                }

                this.showStatus('Exporting media control rules...', 'info');
                this.setExportButtonEnabled(false);

                this.sendMessage({
                    type: 'export-rules-to-showroom',
                    presentationName: presentationName,
                    isNewPresentation: selectedPresentation === 'new',
                    wallName: selectedWall
                });
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'plugin-ready':
                        // Plugin is ready, no status message needed
                        break;
                    case 'drive-connection-status':
                        this.handleDriveConnectionStatus(message);
                        break;
                    case 'presentations-loaded':
                        this.handlePresentationsLoaded(message);
                        break;
                    case 'presentation-conflict':
                        this.handlePresentationConflict(message);
                        break;
                    case 'export-to-showroom-started':
                        this.showStatus('Exporting to Showroom...', 'info');
                        break;
                    case 'export-to-showroom-complete':
                        this.showStatus(`âœ… Exported to: ${message.path}`, 'success');
                        this.setExportButtonEnabled(true);
                        break;
                    case 'export-to-showroom-error':
                        this.showStatus(`Error: ${message.message}`, 'error');
                        this.setExportButtonEnabled(true);
                        break;
                    case 'oauth-authorization-started':
                        this.showStatus(message.message || 'Please authorize in the browser window', 'info');
                        break;
                    case 'prompt-client-id':
                    case 'prompt-access-token':
                        this.showStatus(message.message || 'Please configure OAuth settings', 'info');
                        // Show settings modal
                        this.openModal();
                        break;
                    case 'success':
                        this.showStatus(message.message, 'success');
                        break;
                    case 'settings-loaded':
                        this.handleSettingsLoaded(message);
                        // If Settings modal was requested to be opened, show it now after processing
                        if (this.pendingSettingsOpen) {
                            this.openModal();
                            this.pendingSettingsOpen = false;
                        }
                        break;
                    case 'selection-data':
                        this.handleSelectionData(message);
                        break;
                    case 'generation-started':
                        this.showStatus('Generation started...', 'info');
                        break;
                    case 'generation-complete':
                        this.showStatus('Export complete!', 'success');
                        this.setExportButtonEnabled(true);
                        // Re-enable local export button
                        const exportLocallyButton = document.getElementById('export-locally');
                        if (exportLocallyButton) {
                            exportLocallyButton.disabled = false;
                        }
                        break;
                    case 'generation-error':
                        this.showStatus(`Error: ${message.message}`, 'error');
                        this.setExportButtonEnabled(true);
                        // Re-enable local export button
                        const exportLocallyButtonError = document.getElementById('export-locally');
                        if (exportLocallyButtonError) {
                            exportLocallyButtonError.disabled = false;
                        }
                        break;
                    case 'rules-generated':
                        this.handleRulesGenerated(message);
                        break;
                    case 'export-rules-to-showroom-started':
                        this.showStatus('Exporting media control rules to showroom...', 'info');
                        break;
                    case 'export-rules-to-showroom-complete':
                        this.showStatus(`âœ… Exported to: ${message.path}`, 'success');
                        this.setExportButtonEnabled(true);
                        break;
                    case 'export-rules-to-showroom-error':
                        this.showStatus(`Error: ${message.message}`, 'error');
                        this.setExportButtonEnabled(true);
                        break;
                    case 'rules-error':
                        this.showStatus(`Rules generation error: ${message.message}`, 'error');
                        this.setExportButtonEnabled(true);
                        break;
                    case 'video-files-detected':
                        this.handleVideoFilesDetected(message);
                        break;
                    case 'image-files-detected':
                        this.handleImageFilesDetected(message);
                        break;
                    case 'video-copy-complete':
                        this.handleVideoCopyComplete(message);
                        break;
                    case 'video-copy-error':
                        this.handleVideoCopyError(message);
                        break;
                    case 'copy-file-request':
                        this.handleCopyFileRequest(message);
                        break;
                    case 'download-file':
                        this.handleDownloadFile(message);
                        break;
                    case 'download-file-chunk':
                        this.handleDownloadFileChunk(message);
                        break;
                    case 'error':
                        this.showStatus(`Error: ${message.message}`, 'error');
                        break;
                    default:
                        console.warn('Unknown message type:', message.type);
                }
            }

            handleSettingsLoaded(message) {
                const buildTimeConfig = message.buildTimeConfig || {};
                console.log('ðŸ”§ Loading settings, build-time config:', buildTimeConfig);
                
                // Get all section elements (they should exist in DOM but be hidden by default)
                const clientIdSection = document.getElementById('client-id-section');
                const backendUrlSection = document.getElementById('backend-url-section');
                const serviceAccountSection = document.getElementById('service-account-section');
                const accessTokenSection = document.getElementById('access-token-section');
                const folderIdNotice = document.getElementById('folder-id-build-time-notice');
                
                // All sections are now always visible in the modal
                // Populate values if they exist
                if (clientIdSection) {
                    const clientIdInput = document.getElementById('oauth-client-id');
                    if (clientIdInput) {
                        if (message.clientId) {
                            clientIdInput.value = message.clientId;
                        }
                    }
                }
                
                if (backendUrlSection) {
                    const backendUrlInput = document.getElementById('auth-backend-url');
                    if (backendUrlInput && message.backendUrl) {
                        backendUrlInput.value = message.backendUrl;
                    }
                }
                
                if (serviceAccountSection) {
                    const saInput = document.getElementById('service-account-json');
                    if (saInput && message.hasServiceAccountKey && !saInput.value) {
                        saInput.placeholder = 'Service account key is set (hidden for security)';
                    }
                }
                
                // Access Token section - always visible
                if (accessTokenSection) {
                    const tokenInput = document.getElementById('oauth-access-token');
                    if (tokenInput) {
                        if (message.hasAccessToken && !tokenInput.value) {
                            tokenInput.placeholder = 'Access token is set (hidden for security)';
                        } else {
                            tokenInput.placeholder = 'Paste access token here (fallback if Connect button fails)';
                        }
                        // Ensure input is enabled and focusable
                        tokenInput.disabled = false;
                        tokenInput.readOnly = false;
                    }
                }
                
                // Folder ID - always visible (users can override build-time value)
                const folderIdInput = document.getElementById('drive-folder-id');
                if (folderIdInput) {
                    if (message.folderId) {
                        folderIdInput.value = message.folderId;
                        console.log('ðŸ“‹ Loaded folder ID into settings:', message.folderId);
                    } else {
                        folderIdInput.value = '';
                    }
                }
                
                // Show notice if using build-time folder ID (but field is still visible for override)
                if (buildTimeConfig.hasFolderId && folderIdNotice) {
                    folderIdNotice.style.display = 'block';
                } else if (folderIdNotice) {
                    folderIdNotice.style.display = 'none';
                }
            }

            handleDriveConnectionStatus(message) {
                this.isConnected = message.connected || false;
                const statusElement = document.getElementById('drive-status');
                const statusModal = document.getElementById('drive-status-modal');
                const statusFooter = document.getElementById('drive-status-footer');
                const connectButton = document.getElementById('connect-drive');
                const settingsButton = document.getElementById('settings-drive');
                
                if (this.isConnected) {
                    const statusText = 'Connected';
                    if (statusElement) {
                        if (message.folderId) {
                            statusElement.textContent = `âœ“ ${statusText} (${message.folderId.substring(0, 12)}...)`;
                            statusElement.title = `Folder ID: ${message.folderId}`;
                        } else {
                            statusElement.textContent = `âœ“ ${statusText}`;
                        }
                        statusElement.style.color = '#006600';
                    }
                    if (statusModal) {
                        statusModal.textContent = statusText;
                        statusModal.style.color = '#33a68f';
                    }
                    if (statusFooter) {
                        statusFooter.textContent = statusText;
                        statusFooter.style.color = '#33a68f';
                    }
                    if (connectButton) connectButton.style.display = 'none';
                    if (settingsButton) settingsButton.style.display = 'block';
                } else {
                    const statusText = message.message || 'Not connected';
                    if (statusElement) {
                        statusElement.textContent = statusText;
                        statusElement.style.color = '#cc0000';
                    }
                    if (statusModal) {
                        statusModal.textContent = 'Not connected';
                        statusModal.style.color = '#000';
                    }
                    if (statusFooter) {
                        statusFooter.textContent = 'Not connected';
                        statusFooter.style.color = '#000';
                    }
                    if (connectButton) connectButton.style.display = 'block';
                    if (settingsButton) settingsButton.style.display = 'block';
                }
                this.updateExportButton();
                
                // Reload presentations if connected
                if (this.isConnected) {
                    this.loadPresentations();
                }
            }

            handlePresentationsLoaded(message) {
                this.presentations = message.presentations || [];
                const select = document.getElementById('presentation-select');
                
                select.innerHTML = '';
                
                if (this.presentations.length === 0) {
                    select.innerHTML = '<option value="">No presentations found</option>';
                } else {
                    this.presentations.forEach(presentation => {
                        const option = document.createElement('option');
                        option.value = presentation;
                        option.textContent = presentation;
                        select.appendChild(option);
                    });
                }
                
                // Add separator and "New Presentation" option
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
                select.appendChild(separator);
                
                const newOption = document.createElement('option');
                newOption.value = 'new';
                newOption.textContent = '[+ New Presentation]';
                select.appendChild(newOption);
                
                this.updateExportButton();
            }

            async handlePresentationConflict(message) {
                const sanitizedName = message.sanitizedName;
                const suggestedName = message.suggestedName;
                
                // Show conflict dialog (simplified - in production would be a proper modal)
                const useSuggested = confirm(
                    `âš ï¸ Name Conflict\n\n` +
                    `The name "${sanitizedName}" already exists.\n` +
                    `Suggested name: "${suggestedName}"\n\n` +
                    `Click OK to use the suggested name, or Cancel to edit.`
                );
                
                if (useSuggested) {
                    this.sendMessage({
                        type: 'resolve-presentation-conflict',
                        useSuggested: true,
                        suggestedName: suggestedName,
                        originalData: message.originalData
                    });
                } else {
                    this.setExportButtonEnabled(true);
                    document.getElementById('new-presentation-name').focus();
                }
            }

            handleSelectionData(data) {
                // Selection handling removed - buttons always enabled
                this.updateExportButton();
            }

            handleVideoFilesDetected(message) {
                const videoFiles = message.videoFiles || [];
                if (videoFiles.length > 0) {
                    this.showStatus(`ðŸŽ¥ Found ${videoFiles.length} video file(s): ${videoFiles.map(f => f.filename).join(', ')}`, 'info');
                    
                    // Store video files for later use
                    this.videoFiles = videoFiles;
                } else {
                    // Only log to console for debugging, don't show UI message for no videos
                    console.log('â„¹ï¸ No video files detected in design');
                }
            }

            handleImageFilesDetected(message) {
                const imageFiles = message.imageFiles || [];
                if (imageFiles.length > 0) {
                    this.showStatus(`ðŸ–¼ï¸ Found ${imageFiles.length} image file(s): ${imageFiles.map(f => f.filename).join(', ')}`, 'info');
                    
                    // Store image files for later use
                    this.imageFiles = imageFiles;
                } else {
                    // Only log to console for debugging, don't show UI message for no images
                    console.log('â„¹ï¸ No image files detected in design');
                }
            }

            handleRulesGenerated(message) {
                this.showStatus(`âœ… Generated ${message.metadata.ruleCount} rules`, 'success');
                this.setExportButtonEnabled(true);
                
                // Download the rules JSON file
                if (message.rulesJson && message.filename) {
                    this.downloadFile(message.rulesJson, message.filename);
                }
            }

            handleVideoCopyComplete(message) {
                const videoFiles = message.videoFiles || [];
                this.showStatus(`âœ… Successfully processed ${videoFiles.length} video file(s)`, 'success');
            }

            handleVideoCopyError(message) {
                this.showStatus(`âŒ Error processing video files: ${message.message}`, 'error');
            }

            handleCopyFileRequest(message) {
                // Note: In a Figma plugin environment, we can't directly copy files
                // This is just a placeholder for the copy request
                console.log(`Copy request: ${message.sourcePath} â†’ ${message.destPath}`);
            }

            handleDownloadFileChunk(data) {
                try {
                    const filename = data.filename || 'figma-structure.html';
                    const chunkIndex = data.chunkIndex || 0;
                    const totalChunks = data.totalChunks || 1;
                    
                    console.log(`ðŸ“¦ Received chunk ${chunkIndex + 1}/${totalChunks} for ${filename}`);
                    
                    // Initialize chunk storage for this file if not exists
                    if (!this.chunkedDownloads.has(filename)) {
                        this.chunkedDownloads.set(filename, {
                            chunks: [],
                            totalChunks: totalChunks,
                            videoFiles: [],
                            imageFiles: [],
                            mimeType: data.mimeType || 'text/html'
                        });
                    }
                    
                    const fileData = this.chunkedDownloads.get(filename);
                    fileData.chunks[chunkIndex] = data.content;
                    
                    // Store video and image files from first chunk
                    if (chunkIndex === 0) {
                        if (data.videoFiles) {
                            fileData.videoFiles = data.videoFiles;
                        }
                        if (data.imageFiles) {
                            fileData.imageFiles = data.imageFiles;
                        }
                    }
                    
                    // Check if we have all chunks
                    if (fileData.chunks.length === totalChunks && fileData.chunks.every(chunk => chunk !== undefined)) {
                        console.log(`âœ… All chunks received for ${filename}, assembling file...`);
                        
                        // Assemble the complete file
                        const completeContent = fileData.chunks.join('');
                        
                        // Create download data object
                        const downloadData = {
                            content: completeContent,
                            filename: filename,
                            mimeType: fileData.mimeType,
                            videoFiles: fileData.videoFiles,
                            imageFiles: fileData.imageFiles
                        };
                        
                        // Handle the complete file download
                        this.handleDownloadFile(downloadData);
                        
                        // Clean up chunked data
                        this.chunkedDownloads.delete(filename);
                    }
                    
                } catch (error) {
                    console.error('Error handling download chunk:', error);
                    this.showStatus(`âŒ Error processing file chunk: ${error.message}`, 'error');
                }
            }

            handleDownloadFile(data) {
                try {
                    // Validate data
                    if (!data.content) {
                        console.error('No content provided for download');
                        this.showStatus('Error: No content to download', 'error');
                        return;
                    }

                    console.log('ðŸ“„ Downloading file:', {
                        filename: data.filename,
                        contentLength: data.content.length,
                        hasVideoFiles: data.videoFiles ? data.videoFiles.length : 0,
                        hasImageFiles: data.imageFiles ? data.imageFiles.length : 0
                    });

                    // Try multiple download methods
                    let downloadSuccess = false;

                    // Method 1: Standard blob download
                    try {
                const blob = new Blob([data.content], { type: data.mimeType || 'text/html' });
                const url = URL.createObjectURL(blob);
                
                        if (url && url.startsWith('blob:')) {
                const a = document.createElement('a');
                a.href = url;
                a.download = data.filename || 'figma-structure.html';
                a.style.display = 'none';
                document.body.appendChild(a);
                
                
                a.click();
                document.body.removeChild(a);
                
                            // Delay URL revocation
                            setTimeout(() => {
                                try {
                URL.revokeObjectURL(url);
                                } catch (e) {
                                    console.warn('Could not revoke blob URL:', e);
                                }
                            }, 2000);
                            
                            downloadSuccess = true;
                            this.showStatus('âœ… HTML file downloaded successfully!', 'success');
                        }
                    } catch (blobError) {
                        console.warn('Blob download failed, trying alternative method:', blobError);
                    }

                    // Method 2: Data URL fallback
                    if (!downloadSuccess) {
                        try {
                            const dataUrl = 'data:text/html;charset=utf-8,' + encodeURIComponent(data.content);
                            const a = document.createElement('a');
                            a.href = dataUrl;
                            a.download = data.filename || 'figma-structure.html';
                            a.style.display = 'none';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            
                            downloadSuccess = true;
                            this.showStatus('âœ… HTML file downloaded successfully! (fallback method)', 'success');
                        } catch (dataUrlError) {
                            console.error('Data URL download also failed:', dataUrlError);
                            this.showStatus('âŒ Download failed. Please try again.', 'error');
                        }
                    }
                    
                    // Show media setup instructions if video or image files are detected
                    if (downloadSuccess && ((data.videoFiles && data.videoFiles.length > 0) || (data.imageFiles && data.imageFiles.length > 0))) {
                        setTimeout(() => {
                            this.showMediaSetupInstructions(data.videoFiles || [], data.imageFiles || [], data.filename);
                        }, 1000);
                    } else if (downloadSuccess && (!data.videoFiles || data.videoFiles.length === 0) && (!data.imageFiles || data.imageFiles.length === 0)) {
                        // For exports without media files, just show a simple success message
                        setTimeout(() => {
                            this.showStatus('ðŸŽ‰ Export complete! No media files detected in this design.', 'success');
                        }, 500);
                    }
                    
                } catch (error) {
                    console.error('Error downloading file:', error);
                    this.showStatus(`âŒ Error downloading file: ${error.message}`, 'error');
                }
            }

            showMediaSetupInstructions(videoFiles, imageFiles, htmlFilename) {
                let instructions = '';
                
                if (videoFiles.length > 0) {
                    const videoList = videoFiles.map(f => {
                        const sourcePath = f.sourcePath || 'Unknown path';
                        return `â€¢ ${f.filename} (from: ${sourcePath})`;
                    }).join('\n');
                    
                    const videoCopyCommands = videoFiles.map(f => {
                        const sourcePath = f.sourcePath || 'SOURCE_PATH';
                        return `cp "${sourcePath}" "./video/${f.filename}"`;
                    }).join('\n');
                    
                    instructions += `ðŸŽ¥ Video files detected in your design!
                    
ðŸ“‹ Required video files:
${videoList}

ðŸ“ Video Setup Instructions:
1. Create a "video" directory next to your HTML file
2. Copy your video files using these commands:
\`\`\`bash
mkdir -p video
${videoCopyCommands}
\`\`\`

`;
                }
                
                if (imageFiles.length > 0) {
                    const imageList = imageFiles.map(f => {
                        const sourcePath = f.sourcePath || 'Unknown path';
                        return `â€¢ ${f.filename} (from: ${sourcePath})`;
                    }).join('\n');
                    
                    const imageCopyCommands = imageFiles.map(f => {
                        const sourcePath = f.sourcePath || 'SOURCE_PATH';
                        return `cp "${sourcePath}" "./img/${f.filename}"`;
                    }).join('\n');
                    
                    instructions += `ðŸ–¼ï¸ Image files detected in your design!
                    
ðŸ“‹ Required image files:
${imageList}

ðŸ“ Image Setup Instructions:
1. Create an "img" directory next to your HTML file
2. Copy your image files using these commands:
\`\`\`bash
mkdir -p img
${imageCopyCommands}
\`\`\`

`;
                }
                
                if (videoFiles.length > 0 || imageFiles.length > 0) {
                    const directoryStructure = `${htmlFilename}
${videoFiles.length > 0 ? `video/\n${videoFiles.map(f => `â”œâ”€â”€ ${f.filename}`).join('\n')}` : ''}
${imageFiles.length > 0 ? `img/\n${imageFiles.map(f => `â”œâ”€â”€ ${f.filename}`).join('\n')}` : ''}`;
                    
                    instructions += `ðŸ“‚ Final directory structure:
${directoryStructure}

ðŸŒ Web server examples:
â€¢ python -m http.server 8000
â€¢ npx serve .
â€¢ php -S localhost:8000

âœ… That's it! Your media files will load automatically.`;
                    
                    this.showStatus(instructions, 'info');
                }
            }

            showVideoSetupInstructions(videoFiles, htmlFilename) {
                // Keep this method for backward compatibility
                this.showMediaSetupInstructions(videoFiles, [], htmlFilename);
            }

            createVideoReadme(videoFiles, htmlFilename) {
                const videoList = videoFiles.map(f => `- **${f.filename}** (from frame: ${f.nodeName})`).join('\n');
                
                return `# Video Directory

This directory contains the video files referenced by your HTML design.

## Required Video Files

${videoList}

## Instructions

1. **Create the directory structure** as shown below
2. **Replace the placeholder files** (${videoFiles.map(f => f.filename + '.txt').join(', ')}) with your actual video files
3. **Keep the same filenames** as specified above (remove the .txt extension)
4. **Supported formats**: MP4 (recommended), WebM, OGG
5. **Serve with a web server** - don't open the HTML file directly in the browser

## File Structure

\`\`\`
${htmlFilename}
video/
â”œâ”€â”€ README.md (this file)
${videoFiles.map(f => `â”œâ”€â”€ ${f.filename} (your video file)`).join('\n')}
\`\`\`

## Testing

Use a web server to serve your files:
\`\`\`bash
# Python
python -m http.server 8000

# Node.js
npx serve .

# PHP
php -S localhost:8000
\`\`\`

Then visit: \`http://localhost:8000/${htmlFilename}\`

## Troubleshooting

- **Video not loading**: Make sure you're using a web server, not opening the file directly
- **Wrong filename**: Check that video filenames match exactly (case-sensitive)
- **Unsupported format**: Use MP4 (H.264) for best browser compatibility
`;
            }

            createVideoPlaceholder(videoFile) {
                return `# Placeholder for: ${videoFile.filename}

This is a placeholder file for the video: ${videoFile.filename}

## Frame Information
- **Figma Frame**: ${videoFile.nodeName}
- **Dimensions**: ${videoFile.width} x ${videoFile.height} pixels
- **Node ID**: ${videoFile.nodeId}

## Instructions
1. Delete this placeholder file (${videoFile.filename}.txt)
2. Add your actual video file with the name: ${videoFile.filename}
3. Make sure the video file is in a supported format (MP4 recommended)

## Supported Video Formats
- MP4 (H.264 codec) - Recommended
- WebM
- OGG

## File Size Recommendations
- Keep video files under 50MB for web performance
- Use appropriate compression for your use case
- Consider using multiple quality versions for responsive design
`;
            }


            generateDefaultFilename() {
                // Use the first selected node name as the default filename
                const selectionCount = document.getElementById('selection-count');
                if (selectionCount && selectionCount.textContent) {
                    const text = selectionCount.textContent;
                    // Look for node names in the selection info
                    // This will be enhanced when we get the actual node data
                    if (text.includes('1 node')) {
                        return 'node-export.html';
                    } else if (text.includes('nodes')) {
                        const match = text.match(/(\d+) nodes/);
                        if (match) {
                            return `nodes-${match[1]}-export.html`;
                        }
                    }
                }
                return 'figma-export.html';
            }

            updateExportButton() {
                const exportToShowroomButton = document.getElementById('export-to-showroom');
                const exportLocallyButton = document.getElementById('export-locally');
                const exportRulesButton = document.getElementById('export-rules');
                const presentationSelect = document.getElementById('presentation-select');
                const newPresentationName = document.getElementById('new-presentation-name');
                
                const hasPresentation = presentationSelect.value && 
                    (presentationSelect.value !== 'new' || newPresentationName.value.trim().length > 0);
                
                exportToShowroomButton.disabled = !this.isConnected || !hasPresentation;
                exportLocallyButton.disabled = false; // UXync export is always enabled
                exportRulesButton.disabled = !this.isConnected || !hasPresentation; // Export navigation requires connection and presentation
            }

            setExportButtonEnabled(enabled, includeLocal = false) {
                const exportToShowroomButton = document.getElementById('export-to-showroom');
                const exportLocallyButton = document.getElementById('export-locally');
                const exportRulesButton = document.getElementById('export-rules');
                exportToShowroomButton.disabled = !enabled;
                // Local export can be disabled during export operations, but not by default
                if (includeLocal) {
                    exportLocallyButton.disabled = !enabled;
                }
                exportRulesButton.disabled = !enabled;
            }

            showStatus(message, type = 'info') {
                // Create a temporary status element if it doesn't exist
                let statusElement = document.getElementById('status-message');
                if (!statusElement) {
                    statusElement = document.createElement('div');
                    statusElement.id = 'status-message';
                    statusElement.className = 'status';
                    document.querySelector('.container').appendChild(statusElement);
                }
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
                statusElement.classList.remove('hidden');
                
                // Auto-hide after 3 seconds for success/info messages
                if (type === 'success' || type === 'info') {
                    setTimeout(() => {
                        if (statusElement) {
                            statusElement.classList.add('hidden');
                        }
                    }, 3000);
                }
            }

            downloadFile(content, filename) {
                try {
                    const blob = new Blob([content], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                    }, 100);
                } catch (error) {
                    console.error('Error downloading file:', error);
                    this.showStatus(`Error downloading ${filename}`, 'error');
                }
            }

            sendMessage(message) {
                parent.postMessage({ pluginMessage: message }, '*');
            }
        }

        // Initialize the UI
        new FigmaToHTMLUI();
    </script>
</body>
</html>
</html>